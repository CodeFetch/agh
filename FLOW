- agh main
- agh state setup:
	- allocate state
	- allocates main context
	- allocates main loop

At this point in time, AGH allocated memory for it's state structure. 
Still, some members of that structure are left in an unknown state; 
thus, we need to proceed setting up them.

- handlers setup:
	- allocate memory for handlers queue

- register xmpp core test handler
	If the passed in queue or handler are NULL, function returns doing 
	nothing (except for printing an error message).
	Otherwise, the handler is added to the queue.

- event sources setup:
	- a new signal interception source is installed, it catches sigint only
	- agh core messagin setup happens here:
		- checks if core handlers queue is allocated: if not, warn the user
		- installs a new timeout source, for periodic message checking; will 
		be changed. Source is attached to agh core's GMainContext.
		- handlers for the agh cor are initialized.
			- if an handler is enabled (via the "enabled" member of the 
				handler structure), the function pointed by the 
				handler_initialize pointer of the same structure is invoked
	- threads setup occurs
		- this boils down really to a threads queue allocation
	- xmpp test test thread is registered
		- if thread is null, it won't be registered; function prints an 
		error message only
		- it adds a thread to the thread queue

	Until now, no thread specific code has been executed. this is going to 
	change in the thread preparing phase. here, various members of the 
	thread cntrolstructure are initialized.

	- thread preparing phase:
		- for each thread:
			- a pointer to the core's main loop and main context is provided 
			to threads
			- the asynchronous queue for communications with core is 
			initialized here; this is arguably needed, as arguable would be to 
			start sending message to the core from inside an init function, 
			which is run in core thread by the way.
			- the thread's handlers queue is set to NULL, so that mistakes are 
			easier to find later on
			- specific thread init function gets invoked;

			In the case of the xmpp test thread, this means:
			- allocate memory for thread specific data
			- thread handlers setup happens, like in the core
				- and like in the core this boils down to a queue allocation
			- xmpp test thread registers it's own handler, different from the 
			one in the core
				If the passed in queue or handler are NULL, function returns doing 
				nothing (except for printing an error message).
				Otherwise, an handler is added to the queue.
			- messaging setup routine is invoked (the non-core version):
				this time the function operates on the thread control structure, 
				performing the same tasks as it did on the core.
				- checks if core handlers queue is allocated: if not, warn the 
					user
				- installs a new timeout source, for periodic message hecking;
					will be changed, too. Source is attached to the thread's 
				GMainContext.
			- thread's handlers are initialized
				- if an handler is enabled (via the "enabled" member of the 
					handler structure), the function pointed by the 
					handler_initialize pointer of the same structure is invoked
	- threads are started
		- and for each thread:
			- the function pointed by the thread_main function pointer 
				in the thread control structure is invoked. From now on, the 
				thread may do anything, in "parallel".
	- at this point, each thread gets a test message
	- agh core enters it's main loop, catching unix signals and 
	periodically checking for messages.

	Now, we can exit the main loop for various reasons. Currently, I press 
	ctrl+c, causing a SIGINT signal to be sent to the process.
	At this point, the core will not be able to answer thread messages 
	anymore. In general, we need an orderly exit of our threads.
	** we need to tell each thread to exit, and have it actually exit
		Using messaging seems the obvious choice.
------------------------------------------

Past this line, you can consider this as the shutdown process.

- if we received a SIGINT signal, then we emit a SIGINT message; not 
	very useful, but may be in future.
- threads are stopped, so for each thread:
	- we join the thread, waiting for it to exit. If the thread never does, the core gets stuck.
- we proceed with threads deinitializzation, that can be seen as the opposite of threads preparing
	- for each thread:
		- we invoke the thread's deinit function
		- we check if the thread did release its handlers
		- we unreference the communication queue for this thread, as we are not going to need it anymore
		- the agh_mainloop and agh_maincontext pointers we handed over to the thread are set to NULL
		- if the control structure has the on_stack flag unset, then a warning is emitted to remember we should look at it
		- the thread is removed from the queue
- threads teardown happens: the queue holding our threads is freed
- event sources teardown happens:
	- SIGINT signal interception is stopped
	- messasing, and thus the related timeout even source, are neglected, as are handlers.
	This is a problem that will be fixed now.
- state tardown happens:
	- the main loop (and associated context) are unreferenced
	- AGH state is freed

We have some problems: and in particular, we miss the needed code for proper shutdown.
At the moment the test XMPP thread doesn't even take care to exit - so the core gets always stuck.
